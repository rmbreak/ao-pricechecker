// The following directive is necessary to make the package coherent:

// +build ignore

// This program generates items.go. It can be invoked by running
// go generate

package main

import (
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"os"
	"text/template"
	"time"
)

var templateFile = template.Must(template.New("").Parse(`// Code generated by go generate; DO NOT EDIT.
// This file was generated by robots at
// {{ .Timestamp }}
// using data from
// {{ .URL }}
package marketdata

type Item struct {
	UniqueName   string
	FriendlyName string
	Description  string
}

var Items = []Item{
{{- range .Items }}
	Item{ {{ printf "%q" .UniqueName }}, {{ printf "%q" .FriendlyName.N }}, {{ printf "%q" .Description.D }} },
{{- end }}
}
`))

type Item struct {
	UniqueName   string `json:"UniqueName"`
	FriendlyName struct {
		N string `json:"EN-US"`
	} `json:"LocalizedNames"`
	Description struct {
		D string `json:"EN-US"`
	} `json:"LocalizedDescriptions"`
}

type Items []Item

const url = "https://raw.githubusercontent.com/broderickhyman/ao-bin-dumps/master/formatted/items.json"

func main() {
	resp, err := http.Get(url)
	if err != nil {
		fmt.Fprintf(os.Stderr, "%v\n", err)
		os.Exit(1)
	}
	defer resp.Body.Close()

	items, err := ExtractItems(resp.Body)
	if err != nil {
		fmt.Fprintf(os.Stderr, "failed to parse items: %v\n", err)
		os.Exit(1)
	}

	if err = Output(items); err != nil {
		fmt.Fprintf(os.Stderr, "failed to write out items to items.go: %v\n", err)
		os.Exit(1)
	}
}

func Output(items Items) error {
	f, err := os.Create("marketdata/items.go")
	if err != nil {
		return err
	}
	templateFile.Execute(f, struct {
		Timestamp time.Time
		URL       string
		Items     Items
	}{
		Timestamp: time.Now(),
		URL:       url,
		Items:     items,
	})
	return nil
}

func ExtractItems(r io.Reader) (Items, error) {
	var items Items
	err := json.NewDecoder(r).Decode(&items)
	return items, err
}
