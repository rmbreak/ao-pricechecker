// The following directive is necessary to make the package coherent:

// +build ignore

// This program generates items.go. It can be invoked by running
// go generate

package main

import (
	"encoding/json"
	"fmt"
	"net/http"
	"os"
	"text/template"
	"time"
)

var templateFile = template.Must(template.New("").Parse(`// Code generated by go generate; DO NOT EDIT.
// This file was generated by robots at
// {{ .Timestamp }}
// using data from
// {{ .ItemsURL }}
// and
// {{ .LocalizationsURL }}
package marketdata

type Item struct {
	UniqueName   string
	FriendlyName string
	Description  string
}

var Items = []Item{
{{- range .Items }}
	Item{ {{ printf "%q" .UniqueName }}, {{ printf "%q" .FriendlyName.N }}, {{ printf "%q" .Description.D }} },
{{- end }}
}
`))

type ItemName struct {
	UniqueName string `json:"@uniquename"`
}

type ItemsRawJSON struct {
	Items struct {
		FarmableItem                []ItemName `json:"farmableitem"`
		SimpleItem                  []ItemName `json:"simpleitem"`
		ConsumableItem              []ItemName `json:"consumableitem"`
		ConsumableFromInventoryItem []ItemName `json:"consumablefrominventoryitem"`
		EquipmentItem               []ItemName `json:"equipmentitem"`
		Weapon                      []ItemName `json:"weapon"`
		Mount                       []ItemName `json:"mount"`
		FurnitureItem               []ItemName `json:"furnitureitem"`
		JournalItem                 []ItemName `json:"journalitem"`
	} `json:"items"`
}

type LocalizationsRawJSON struct {
	Tmx struct {
		Body struct {
			Tu []struct {
				TUID string      `json:"@tuid"`
				Tuv  interface{} `json:"tuv"`
				// Tuv  []struct {
				// 	Lang string `json:"@xml:lang"`
				// 	Seg  string `json:"seg"`
				// } `json:"tuv"`
			} `json:"tu"`
		} `json:"body"`
	} `json:"tmx"`
}

type Item struct {
	UniqueName   string `json:"UniqueName"`
	FriendlyName struct {
		N string `json:"EN-US"`
	} `json:"LocalizedNames"`
	Description struct {
		D string `json:"EN-US"`
	} `json:"LocalizedDescriptions"`
}

type Items []Item

const (
	url              = "https://raw.githubusercontent.com/broderickhyman/ao-bin-dumps/master/formatted/items.json"
	itemsURL         = "https://raw.githubusercontent.com/broderickhyman/ao-bin-dumps/master/items.json"
	localizationsURL = "https://raw.githubusercontent.com/broderickhyman/ao-bin-dumps/master/localization.json"
)

// Converts from "@ITEMS_T4_BAG" to "Adept's Bag"
func (l *LocalizationsRawJSON) uniqueNameToLocalization(s string) string {
	for _, tu := range l.Tmx.Body.Tu {
		if tu.TUID == s {
			switch v := tu.Tuv.(type) {
			case []interface{}:
				for _, tuv := range v {
					tuvMap := tuv.(map[string]interface{})
					langS := tuvMap["@xml:lang"].(string)
					if langS == "EN-US" {
						return tuvMap["seg"].(string)
					}
				}
			case map[string]interface{}:
				langS := v["@xml:lang"].(string)
				if langS == "EN-US" {
					return v["seg"].(string)
				}
			}
		}
	}
	return ""
}

// Converts from "T4_BAG" to ("Adept's Bag", "Equipment Item")
func (l *LocalizationsRawJSON) uniqueToFriendlyAndDescription(s string) (string, string) {
	friend := l.uniqueNameToLocalization("@ITEMS_" + s)
	desc := l.uniqueNameToLocalization("@ITEMS_" + s + "_DESC")

	return friend, desc
}

func main() {
	var itemsJSON ItemsRawJSON
	var localizationJSON LocalizationsRawJSON

	// openAndDecode("marketdata/items.json", &itemsJSON)
	// openAndDecode("marketdata/localization.json", &localizationJSON)
	fetchAndDecode(itemsURL, &itemsJSON)
	fetchAndDecode(localizationsURL, &localizationJSON)

	// get each item info
	allitems := [][]ItemName{
		itemsJSON.Items.FarmableItem,
		itemsJSON.Items.SimpleItem,
		itemsJSON.Items.ConsumableItem,
		itemsJSON.Items.ConsumableFromInventoryItem,
		itemsJSON.Items.EquipmentItem,
		itemsJSON.Items.Weapon,
		itemsJSON.Items.Mount,
		itemsJSON.Items.FurnitureItem,
		itemsJSON.Items.JournalItem,
	}
	var items Items
	for _, itemnames := range allitems {
		for _, v := range itemnames {
			friendly, description := localizationJSON.uniqueToFriendlyAndDescription(v.UniqueName)
			var item Item
			item.UniqueName = v.UniqueName
			item.FriendlyName.N = friendly
			item.Description.D = description
			items = append(items, item)
		}
	}

	if err := Output(items); err != nil {
		fmt.Fprintf(os.Stderr, "failed to write out items to items.go: %v\n", err)
		os.Exit(1)
	}
}

func Output(items Items) error {
	f, err := os.Create("marketdata/items.go")
	if err != nil {
		return err
	}
	templateFile.Execute(f, struct {
		Timestamp        time.Time
		ItemsURL         string
		LocalizationsURL string
		Items            Items
	}{
		Timestamp:        time.Now(),
		ItemsURL:         itemsURL,
		LocalizationsURL: localizationsURL,
		Items:            items,
	})
	return nil
}

func fetchAndDecode(url string, p interface{}) {
	resp, err := http.Get(url)
	if err != nil {
		fmt.Fprintf(os.Stderr, "%v\n", err)
		os.Exit(1)
	}
	defer resp.Body.Close()

	err = json.NewDecoder(resp.Body).Decode(p)
	if err != nil {
		fmt.Fprintf(os.Stderr, "%v\n", err)
		os.Exit(1)
	}
}

func openAndDecode(path string, p interface{}) {
	f, err := os.Open(path)
	if err != nil {
		fmt.Fprintf(os.Stderr, "%v\n", err)
		os.Exit(1)
	}

	err = json.NewDecoder(f).Decode(p)
	if err != nil {
		fmt.Fprintf(os.Stderr, "%v\n", err)
		os.Exit(1)
	}
}
